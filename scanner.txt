%{

#define KW_IF 256
#define IDENTIFIER 257
#define LIT_INTEGER 258
#define ERROR 259

int lineNumber =0;
int running = 1;
}%

DIGIT	[0-9]

%x COMM

%%

"if"	{ return KW_IF; }
"int"	{ return KW_INT; }
[a-zA-Z_][a-zA-Z_0-9]*	{ return IDENTIFIER; }	//pega qualquer palavra de a-z

"("	{ return yytext[0]; }	//retorna o proprio numero do caracter em ascii
")"	{ return yytext[0]; }
";"	{ return yytext[0]; }


{DIGIT}+	{ return LIT_INTEGER; } //yytext contem a ultima coisa que casou com a expressão regular

[ \t]	//ignora espaço e tabulação

.	{ return ERROR; }

"\n"	{ ++lineNumber;}
"//".*		//ignora comentários

"/*"	{ BEGIN(COMM); }

<COMM>"*/"	{ BEGIN(INITIAL); }
<COMM>"\n"	{ ++lineNumber; }
<COMM>.


%%

main ()	//pro trabalho não pode ter a main, tem que ser separado
{
	int token = 0;
	while (running)
	{
		token = yylex();
	
		switch(token)
		{
			case KW_IF:
				printf("Palavra reservada IF\n");
				break;
			case IDENTIFIER:
				printf("Identificador\n");
				break;
			case '(':
				printf("(");
				break;
			case ')':
				printf(")");
				break;
			case ';':
				printf(";");
				break;
			case LIT_INTEGER:
				printf("Achei um lexema %s\n", yytext);
				break;
			case ERROR:
				printf("Alguma coisa estranha\n");
				break;
		}
	}

	printf("Tem %d linhas", lineNumber);
}

yywrap()
{
	runnning  = 0;
	return 1;
}

